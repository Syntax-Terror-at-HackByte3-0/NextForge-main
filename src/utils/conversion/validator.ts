/**
 * Validates converted Next.js code and applies automatic fixes
 */
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';
import type { ParserOptions, ParserPlugin } from '@babel/parser';
import { ConversionOutput } from './types';
import { logConversion } from './logger';
import { convertReactRouterToNextRouter, ensureExportDefault } from './componentConverter';

/**
 * Validates converted Next.js code for common issues and applies fixes
 */
export const validateConversion = (output: ConversionOutput): { 
  valid: boolean; 
  errors: string[];
  warnings: string[];
  fixes: Record<string, string>; 
} => {
  const result = {
    valid: true,
    errors: [] as string[],
    warnings: [] as string[],
    fixes: {} as Record<string, string>
  };
  
  // Check for empty output
  if (Object.keys(output.pages).length === 0 && 
      Object.keys(output.components).length === 0) {
    result.valid = false;
    result.errors.push('Conversion produced no pages or components');
    return result;
  }
  
  // Validate syntax for all generated files
  validateFiles(output.pages, 'pages', result);
  validateFiles(output.components, 'components', result);
  validateFiles(output.api, 'api', result);
  
  // Check for critical Next.js files
  if (!output.pages['_app.js'] && !output.pages['_app.tsx']) {
    // Create a basic _app file
    const hasTypeScript = Object.keys(output.pages).some(file => file.endsWith('.tsx'));
    const appFileExt = hasTypeScript ? '.tsx' : '.js';
    
    const appFileContent = hasTypeScript ? 
      `import type { AppProps } from 'next/app';
import '../styles/globals.css';

function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}

export default MyApp;
` :
      `import '../styles/globals.css';

function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />;
}

export default MyApp;
`;
    
    output.pages[`_app${appFileExt}`] = appFileContent;
    result.fixes[`pages/_app${appFileExt}`] = appFileContent;
    logConversion('info', 'Created default _app page');
  }
  
  if (!output.pages['index.js'] && !output.pages['index.tsx']) {
    // Create a basic index file
    const hasTypeScript = Object.keys(output.pages).some(file => file.endsWith('.tsx'));
    const indexFileExt = hasTypeScript ? '.tsx' : '.js';
    
    const indexFileContent = hasTypeScript ?
      `import type { NextPage } from 'next';
import Head from 'next/head';

const Home: NextPage = () => {
  return (
    <div>
      <Head>
        <title>Next.js App</title>
        <meta name="description" content="Generated by Next.js" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main>
        <h1>Welcome to Next.js!</h1>
      </main>
    </div>
  );
};

export default Home;
` :
      `import Head from 'next/head';

export default function Home() {
  return (
    <div>
      <Head>
        <title>Next.js App</title>
        <meta name="description" content="Generated by Next.js" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main>
        <h1>Welcome to Next.js!</h1>
      </main>
    </div>
  );
}
`;
    
    output.pages[`index${indexFileExt}`] = indexFileContent;
    result.fixes[`pages/index${indexFileExt}`] = indexFileContent;
    logConversion('info', 'Created default index page');
  }
  
  // Check for inconsistent file extensions
  const hasJsFiles = Object.keys(output.pages).some(file => file.endsWith('.js'));
  const hasTsFiles = Object.keys(output.pages).some(file => file.endsWith('.tsx') || file.endsWith('.ts'));
  
  if (hasJsFiles && hasTsFiles) {
    result.warnings.push('Mixed JavaScript and TypeScript files detected. Consider standardizing on one format.');
  }
  
  // Return validation results with auto-fixed files
  logConversion('info', `Validation complete. Found ${result.errors.length} errors, ${result.warnings.length} warnings`);
  if (result.errors.length > 0) {
    result.valid = false;
    result.errors.forEach(error => logConversion('error', error));
  }
  
  result.warnings.forEach(warning => logConversion('warning', warning));
  
  return result;
};

/**
 * Validates files for syntax errors and common Next.js issues
 * Applies automatic fixes where possible
 */
const validateFiles = (
  files: Record<string, string>, 
  category: string, 
  result: { 
    valid: boolean; 
    errors: string[]; 
    warnings: string[]; 
    fixes: Record<string, string>; 
  }
) => {
  Object.entries(files).forEach(([filename, content]) => {
    try {
      // First check for React Router code and convert it
      if (content.includes('react-router') || 
          content.includes('<Route') || 
          content.includes('<Routes') || 
          content.includes('useNavigate') || 
          content.includes('useHistory')) {
        const fixedContent = convertReactRouterToNextRouter(content);
        if (fixedContent !== content) {
          files[filename] = fixedContent;
          result.fixes[`${category}/${filename}`] = fixedContent;
          result.warnings.push(`${filename}: Contains React Router code which has been automatically converted to Next.js`);
        }
      }
      
      // Check for export default in page components
      if (category === 'pages' && !content.includes('export default')) {
        // Extract main component name or use filename
        const componentName = extractComponentName(content, filename);
        
        // Add export default at the end
        const fixedContent = ensureExportDefault(content, componentName); 
        files[filename] = fixedContent;
        result.fixes[`${category}/${filename}`] = fixedContent;
        result.errors.push(`${filename}: Page component missing export default - automatically fixed`);
      }
      
      // Parse the AST to validate syntax
      try {
        const parserOptions: ParserOptions = {
          sourceType: 'module',
          plugins: ['jsx', 'typescript', 'classProperties'] as ParserPlugin[],
          allowImportExportEverywhere: true // Allow imports in more contexts
        };
        
        const ast = parse(content, parserOptions);
        
        // Check for common Next.js issues
        const issues = validateNextJsPattern(ast, filename, category);
        
        if (issues.errors.length > 0) {
          result.errors.push(...issues.errors.map(e => `${filename}: ${e}`));
          result.valid = false;
        }
        
        if (issues.warnings.length > 0) {
          result.warnings.push(...issues.warnings.map(w => `${filename}: ${w}`));
        }
        
        // Apply automatic fixes if available
        if (issues.fix) {
          files[filename] = issues.fix;
          result.fixes[`${category}/${filename}`] = issues.fix;
        }
      } catch (parseError) {
        // If we can't parse the file, try to fix common syntax issues before reporting an error
        if (category === 'pages' && !content.includes('export default')) {
          const componentName = extractComponentName(content, filename);
          const fixedContent = `
function ${componentName}() {
  return (
    <div>
      <h1>${componentName}</h1>
    </div>
  );
}

export default ${componentName};
`;
          files[filename] = fixedContent;
          result.fixes[`${category}/${filename}`] = fixedContent;
          result.errors.push(`${filename}: Syntax error, created a basic component - ${(parseError as Error).message}`);
        } else {
          result.errors.push(`${filename}: Syntax error - ${(parseError as Error).message}`);
          result.valid = false;
        }
      }
    } catch (error) {
      result.valid = false;
      result.errors.push(`Error validating ${filename}: ${(error as Error).message}`);
    }
  });
};

/**
 * Extract component name from file content or filename
 */
const extractComponentName = (content: string, filename: string): string => {
  // Try to extract from function/class/const declarations
  const functionMatch = content.match(/function\s+([A-Z][A-Za-z0-9_]*)/);
  const constMatch = content.match(/const\s+([A-Z][A-Za-z0-9_]*)\s*=/);
  const classMatch = content.match(/class\s+([A-Z][A-Za-z0-9_]*)/);
  const arrowMatch = content.match(/const\s+([A-Z][A-Za-z0-9_]*)\s*=\s*\(/);
  
  // If we found a match, use it
  if (functionMatch?.[1] || constMatch?.[1] || classMatch?.[1] || arrowMatch?.[1]) {
    return functionMatch?.[1] || constMatch?.[1] || classMatch?.[1] || arrowMatch?.[1] || '';
  }
  
  // Otherwise, derive from filename
  const baseName = filename.split('/').pop()?.replace(/\.(jsx?|tsx?)$/, '') || '';
  
  // Convert to PascalCase
  return baseName
    .split(/[-_.]/)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
};

/**
 * Validates Next.js patterns in a file
 */
const validateNextJsPattern = (
  ast: any, 
  filename: string, 
  category: string
): { 
  errors: string[]; 
  warnings: string[]; 
  fix?: string;
} => {
  const issues = {
    errors: [] as string[],
    warnings: [] as string[],
    fix: undefined as string | undefined
  };
  
  // For pages, check for proper export default
  if (category === 'pages' && !filename.startsWith('_')) {
    let hasDefaultExport = false;
    
    traverse(ast, {
      ExportDefaultDeclaration() {
        hasDefaultExport = true;
      }
    });
    
    if (!hasDefaultExport) {
      issues.errors.push('Page component missing export default');
    }
  }
  
  // For API routes, check for proper handler export
  if (category === 'api') {
    let hasApiHandler = false;
    
    traverse(ast, {
      ExportDefaultDeclaration(path) {
        if (path.node.declaration && 
            path.node.declaration.type === 'FunctionDeclaration') {
          hasApiHandler = true;
        }
      }
    });
    
    if (!hasApiHandler) {
      issues.errors.push('API route missing export default function handler');
    }
  }
  
  // Check for invalid React Router patterns
  let hasReactRouterPattern = false;
  traverse(ast, {
    JSXElement(path) {
      if (path.node.openingElement.name.type === 'JSXIdentifier') {
        const elementName = path.node.openingElement.name.name;
        if (['BrowserRouter', 'Routes', 'Route'].includes(elementName)) {
          hasReactRouterPattern = true;
          issues.warnings.push(`Contains React Router component <${elementName}> which is not compatible with Next.js routing`);
        }
      }
    },
    CallExpression(path) {
      if (path.node.callee.type === 'Identifier' && 
          ['useNavigate', 'useLocation', 'useParams', 'useHistory'].includes(path.node.callee.name)) {
        hasReactRouterPattern = true;
        issues.warnings.push(`Uses React Router hook ${path.node.callee.name}() which should be replaced with Next.js useRouter()`);
      }
    }
  });
  
  return issues;
};
